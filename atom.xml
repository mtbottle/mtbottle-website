<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Michelle's [uncreative adjective] Blog</title>
    <link href="http://michtran.ca/blog//atom.xml" rel="self" />
    <link href="http://michtran.ca/blog/" />
    <id>http://michtran.ca/blog//atom.xml</id>
    <author>
        <name>Michelle Tran</name>
        <email>email@michtran.ca</email>
    </author>
    <updated>2023-01-01T00:00:00Z</updated>
    <entry>
    <title>Retrospective on 2022</title>
    <link href="http://michtran.ca/blog//blog/posts/2023-01-01-retrospective.html" />
    <id>http://michtran.ca/blog//blog/posts/2023-01-01-retrospective.html</id>
    <published>2023-01-01T00:00:00Z</published>
    <updated>2023-01-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
<em>Posted on January  1, 2023</em>
    
</div>

<p>Wow, time goes by so quickly. In summary: it was a bad year for crypto-currencies, social media, Ukraine, Tesla, Pakistan and the climate. I do hope that there’s finally a reckoning with unsustainable (North American) car-centric lifestyle and it’s cost on the climate, mental and physical health, and maintenance/usage cost (subsidized by cheap oil and the fact that infrastructure is fairly new).</p>
<p>As for myself, I got sick a lot this year. This is what life is like with a toddler in daycare. However, I never tested positive for COVID even though I was fairly ill several times this year. And I’m still recovering from something, so starting off the new year still mildly sick.</p>
<p>I started writing more in my free time and made an effort to publish more this year. I made it more convienient to jot down notes or blog ideas by having a shared central location to access my writings across devices, which was the main reason for my success with publishing more stuff this year.</p>
<p>Early in the year, I wrote about my laptop being on the verge of explosion. I ended up giving away that 2015 MBP which was then replaced by a free one that I got from my job when I quit (2019 MBP). I also got myself a new Samsung Tablet which I still use a surprising amount.</p>
<p>It’s hard to make a decision on my favourite book this year, but if I had to narrow it down, it would be between:</p>
<ul>
<li><a href="https://www.goodreads.com/book/show/30312747-not-quite-narwhal">Not Quite Narwhal</a></li>
<li><a href="https://www.goodreads.com/book/show/36748607-p-is-for-pterodactyl">P is for Pterodactyl</a></li>
<li><a href="https://www.goodreads.com/book/show/54809220-the-rock-from-the-sky">The Rock from the Sky</a> (don’t actually read this to a 2 year old though, it’s kind of scary for them)</li>
</ul>
<p>They all happen to be children’s books, none of which are at the right level for my toddler. I’m not sure what that says about me.</p>
<p>The <em>“Great Resignation”</em> was full in effect at the beginning of the year. However as we approached the end of the year, there were many layoffs. Even then, I decided to change my job during this time.</p>
<p>I had enjoyed working at my previous company. The people were great, company was renowned and the projects were mostly interesting. After a team change at the beginning of the year, I found myself slipping from being one of the team’s most senior people (more or less acting as a team lead) to being right in the middle or on the middle-junior side of the team. This meant that all the interesting large projects that I wanted to lead were slowly becoming out of reach and be given to those more <em>senior</em> than me (and I’ll probably be left with smaller projects at <em>“my level”</em>, due to a slowly creeping title inflation that left me inflated out). I decided that to fix this problem, I would have to either <em>actually</em> work on promotion (which included compiling a “promo” package where I write a 10 page document convincing a panel of random peers that I deserve to be promoted) or move elsewhere. Moving elsewhere was apparently much faster and easier. And my new company also checks off another career bucket list item, so total win-win.</p>
<p>Lastly, some of my favourite phrases coming from my toddler this year:</p>
<ul>
<li>“water is too wet”</li>
<li>“that was a BIG one”</li>
<li>“RAWR! I lion/tiger/bear”</li>
<li>“no kick mama, kick dada”</li>
<li>“you have a big butt!”</li>
<li>“I love you yellow blankey”</li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Reflecting on 10 years as a Software Developer</title>
    <link href="http://michtran.ca/blog//blog/posts/2022-12-22-Reflecting_10_years.html" />
    <id>http://michtran.ca/blog//blog/posts/2022-12-22-Reflecting_10_years.html</id>
    <published>2022-12-22T00:00:00Z</published>
    <updated>2022-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
<em>Posted on December 22, 2022</em>
    
</div>

<p>This year, I celebrate 10 years as a Software Developer. Admittedly, I’m still a bit surprised that I’m still in the same industry, especially since I kind of got into it by accident. Being a software developer has been a fairly fulfilling career, as much as a career under capitalism can be fulfilling. I have a good income and a relatively flexible schedule.</p>
<p>Over the years, I’ve intentionally chosen jobs where I get to learn something. This has led me to work in many different companies, from large public enterprises to 10 people startups. All the companies I’ve worked for were considered “tech” companies, although they all ranged from e-commerce, data science, fintech, and devops. In that sense, my experience is biased towards companies that treat their developers as first tier employees (compared to companies which hire developers, but tech isn’t their product).</p>
<p>I’ve recently decided (ie. in the last few months) that I want to become a Software Architect. How did I manage being a Software Developer for 10(!!!) years without knowing what I wanted in the end? I imagine this is a pretty common scenario for most people. I realized this after reading Staff Engineer (by Will Larson), Fundamentals of Software Architecture (by Mark Richards, Neal Ford), and also working closely with some Staff Engineers at my previous company then thinking: <em>“hey, I want to do what they’re doing and I probably won’t suck at it”</em>.</p>
<p>Most technical problems have already been solved by a bigger and better resourced company than yours. Being “in the know” of these solutions and knowing how they fit into your product roadmap is a skill in itself.</p>
<p>The more senior you get, the more that writing and communication skills matter. This is where having a liberal arts degree will prove useful.</p>
<p>I have a horrible tendency to be very glib when discussing things in person. My excuse for this is because I find it fun to think up ridiculous scenarios to solve a problem, and take it half seriously (example: suggesting that we trade a person on the team with some service ownership changes). I’m realizing now that being more senior means needing to be taken more seriously, which means that I’m going to have to be more thoughtful when I say something. At best, maybe there is some insight that will help contribute to the final solution. But at worst, people will question my competance. Maybe there’s a balance that I haven’t perfected yet. Being fully remote (and also having a different tone when writing) definitely helps.</p>
<p>All successful companies will have an interesting scaling challenge. I haven’t interviewed with a company that did not talk about their exciting scaling challenge.</p>
<p>Self-promotion, or promotion of an idea is an undervalued skill. It’s an almost contradictory skill to what makes someone a good software developer (ie. discerning and critical assessment of code/proposal). I struggle with this, but also realize that if I want to be an effective leader (and climb the corporate ranks <em>shudder</em>) then this is something that I need to work on.</p>
<p>You owe no company your labour and time outside your contract. No matter how much a company describes their culture as a “family” or that they care about their employees, remember that they care way more about their shareholders and profit.</p>
<p>Being oncall is valuable experience. All engineers should go oncall at least for some portion of their careers, but the best companies are the ones who compensate properly for the extra hours of being standby. Going oncall for a week requires lifestyle changes and extra cognitive overhead that wouldn’t have occurred otherwise (like carrying around your laptop for outings where you’re going more than 15 mins away from home, only going places where you will have good internet reception, and ensuring that there’s someone else there to pick up caring for your toddler when/if you have to drop everything to attend to a page). That being said, I still get a sinking feeling in my chest when a page goes off (oncall PTSD maybe).</p>
<p>Some bucket-list career things that I still maybe want to achieve:</p>
<ul>
<li>work at a consultancy or do freelance work</li>
<li>give a talk at a conference (was more important to me maybe 5 years ago, but now I don’t really enjoy going to conferences nor do I actually like to listen to conference talks for learning)</li>
<li>work at a non-profit doing something medical, legal or climate adjacent. I want to make the world better.</li>
<li>figure out what I really want to be when I grow up</li>
</ul>
<p>Finally, a secret confession: I don’t do that much coding for fun.</p>
]]></summary>
</entry>
<entry>
    <title>Elixir: An Exit Review</title>
    <link href="http://michtran.ca/blog//blog/posts/2022-10-29-Elixir-Exit-Review.html" />
    <id>http://michtran.ca/blog//blog/posts/2022-10-29-Elixir-Exit-Review.html</id>
    <published>2022-10-29T00:00:00Z</published>
    <updated>2022-10-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
<em>Posted on October 29, 2022</em>
    
</div>

<p>I’ve resigned from my job at <code>$COMPANY_THAT_USES_ELIXIR</code> recently. And in my next role, Elixir will not be my primary programming language. Here are some of my thoughts after working with it for 3 years.</p>
<h2 id="introduction">Introduction</h2>
<p>Elixir is a language that is based off of Erlang. This means that it uses the BEAM, which is the Erlang’s virtual machine and also follows Erlang’s OTP design principles.</p>
<p>I went into the job not knowing much about the language, other than the fact that it was 1. functional and 2. saw that it was hyped on places like <code>lobste.rs</code> and our favourite orange tech news aggregation website.</p>
<h2 id="what-i-liked">What I liked</h2>
<h3 id="pattern-matching-and-guards">Pattern Matching and Guards</h3>
<p>This simple feature makes programming so much more fun. I’ve mainly used this to substitute for conditionals. For example, handling different response statuses can look like this:</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir"><span class="kw">def</span> handle_resp(%<span class="dt">HTTPoison</span>.<span class="dt">Response</span>{<span class="st">status_code:</span> <span class="dv">200</span>} = resp), <span class="kw">do</span>: ok(resp)

<span class="kw">def</span> handle_resp(%<span class="dt">HTTPoison</span>.<span class="dt">Response</span>{<span class="st">status_code:</span> <span class="dv">403</span>} = resp), <span class="kw">do</span>: forbidden(resp)

<span class="kw">def</span> handle_resp(%<span class="dt">HTTPoison</span>.<span class="dt">Response</span>{<span class="st">status_code:</span> <span class="dv">400</span>} = resp), <span class="kw">do</span>: not_found(resp)

<span class="kw">def</span> handle_resp(%<span class="dt">HTTPoison</span>.<span class="dt">Response</span>{<span class="st">status_code:</span> status} = resp) <span class="kw">when</span> status &gt;= <span class="dv">400</span> <span class="kw">and</span> status &lt; <span class="dv">500</span> <span class="kw">do</span>
  user_error(resp)
<span class="kw">end</span>

<span class="co"># handles all other responses, including 3xx, 5xx</span>
<span class="kw">def</span> handle_resp(%<span class="dt">HTTPoison</span>.<span class="dt">Response</span>{} = resp), <span class="kw">do</span>: retry()</code></pre></div>
<p>I’ve found this to be a super elegant way of differentiating the code paths without creating too many levels of indentation. Pattern matching is also super useful to get specific items from maps and more complex data structures too.</p>
<h3 id="pipes">Pipes!</h3>
<p>In particular, the structure of pipes naturally follows the order they’re executed. This makes it <em>so</em> much easier to read the code.</p>
<p>For example, in a standard declarative language, you might write something like this:</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir">last_func(
    third_func(
        second_func(
            first_func(
                param
            )
        )
    )
)</code></pre></div>
<p>But with Elixir, this can be written much more elegantly:</p>
<pre><code>param
|&gt; first_func()
|&gt; second_func()
|&gt; third_func()
|&gt; last_func()</code></pre>
<p>More languages should adopt this.</p>
<h2 id="what-im-not-sure-about">What I’m not sure about</h2>
<h3 id="genservers-and-otp-design-generally">GenServers (and OTP design generally)</h3>
<p>I was super excited to learn <a href="https://www.erlang.org/doc/design_principles/des_princ.html">about OTP</a> and building applications based on multiple processes. It’s a unique concept with interesting design implications. Thinking in terms of processes, their lifecycles and designing your data around immutability was a fascinating adventure into something completely unique from the standard object-oriented or even functional world.</p>
<p>Although this was intellectually interesting, I don’t think I’ve actually seen it used to its full potential as we seldom needed to code our own GenServers. So admittedly, although this was an interesting excursion into a new idea, I’m not sure I have seen a particularly notable usage of OTP.</p>
<h3 id="interns-struggle-to-onboard">Interns Struggle to Onboard</h3>
<p>Throughout my 3 years at <code>$COMPANY_THAT_USES_ELIXIR</code>, I’ve found that interns, especially those that are on their first 4 month term with us, really struggle to grasp the language as quickly as other more common languages like Javascript or Python. I’m not entirely sure if my anecdotal evidence is indicative of anything, but it does suggest that there might be something different with Elixir that makes it harder for new coders to get started. Some of my theories for why it’s harder:</p>
<ol style="list-style-type: decimal">
<li>Students are more likely to learn OOP at school</li>
<li>OTP architectural design doesn’t translate well to more mainstream languages/patterns</li>
<li>Elixir pattern matching, control flows and error handling also doesn’t translate well to more mainstream languages/patterns, which means that prior programming experience doesn’t map as well to patterns used in Elixir</li>
<li>Four months is not long enough to get a good handle on the idiosyncrasies in the language</li>
</ol>
<p>I’ve found that interns on their second or third internship with <code>$COMPANY_THAT_USES_ELIXIR</code> tended to handle the tasks much better.</p>
<h2 id="what-i-didnt-like">What I didn’t like</h2>
<h3 id="with-statements">“with” Statements</h3>
<p>I’ve actually grown a bit more ambivalent with this construct over time. I started to <em>really</em> hate this construct when I ran into some debugging annoyances. For example:</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir">with {<span class="st">:ok</span>, data}      &lt;- function_call(params),
     {<span class="st">:ok</span>, more_data} &lt;- function_call2(),
<span class="kw">do</span>
  whatever_here()
<span class="kw">else</span>
  {<span class="st">:error</span>, <span class="st">:timeout</span>} -&gt; {<span class="st">:error</span>, <span class="st">:error_in_with_statement</span>}
<span class="kw">end</span></code></pre></div>
<p>It is impossible to know whether the <code>timeout</code> came from <code>function_call</code> or <code>function_call2</code>. So it’s incredibly hard to trace this call when all you see is <code>{:error, :error_in_with_statement}</code> (not to mention that Elixir’s debugging tools are not great).</p>
<p>One way to get around this is to actually annotate each line like this:</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir">with {<span class="st">:this_line</span>, {<span class="st">:ok</span>, data}}      &lt;- {<span class="st">:this_line</span>, function_call(params)},
     {<span class="st">:that_line</span>, {<span class="st">:ok</span>, more_data}} &lt;- {<span class="st">:that_line</span>, function_call2()},
<span class="kw">do</span>
  whatever_here()
<span class="kw">else</span>
  {<span class="st">:this_line</span>, {<span class="st">:error</span>, <span class="st">:timeout</span>}} -&gt; 
    add_some_metrics(<span class="st">:this_line</span>)
    {<span class="st">:error</span>, <span class="st">:error_in_with_statement</span>}

  {<span class="st">:that_line</span>, {<span class="st">:error</span>, <span class="st">:timeout</span>}} -&gt; {<span class="st">:error</span>, <span class="st">:error_in_with_statement</span>}
<span class="kw">end</span></code></pre></div>
<p>This is a reasonable to separate which line caught the error, but makes the code more repetitive (ie. <code>this_line</code> and <code>that_line</code> are repeated 3 times).</p>
<p>I think that <code>with</code> is powerful when you really want to handle a class of errors the same way. Arguably, <code>timeouts</code> <em>should</em> probably be handled the same, but we still need to differentiate where they’re coming from for observability. We can probably use the clunky appended signifier to handle the error in the same way, but differentiated for observability purposes:</p>
<div class="sourceCode"><pre class="sourceCode elixir"><code class="sourceCode elixir">with {<span class="st">:this_line</span>, {<span class="st">:ok</span>, data}}      &lt;- {<span class="st">:this_line</span>, function_call(params)},
     {<span class="st">:that_line</span>, {<span class="st">:ok</span>, more_data}} &lt;- {<span class="st">:that_line</span>, function_call2()},
<span class="kw">do</span>
  whatever_here()
<span class="kw">else</span>
  {line_signifier, {<span class="st">:error</span>, <span class="st">:timeout</span>}} -&gt;
    add_some_metrics(line_signifier)
    {<span class="st">:error</span>, <span class="st">:error_in_with_statement</span>}
<span class="kw">end</span></code></pre></div>
<p>It’s still a bit repetitive, but gives us the observability for debugging. Anyways, I’ve come to terms that this isn’t <em>that</em> terrible. I’m not sure I <em>like</em> it that much, but I guess I no longer hate it.</p>
<h3 id="lacking-good-third-party-support">Lacking good third party support</h3>
<p>My criticism here is probably more on my ex-company rather than something inherent to Elixir itself.</p>
<p>Elixir is still very immature, and hence, there is a clear lack of support for things that we take for granted in other more mature languages.</p>
<p>This was admittedly, one of the final contributing factors to making me leave <code>$COMPANY_THAT_USES_ELIXIR</code> (there were several others reasons unrelated to Elixir). I was no longer excited with working in Elixir because third party libraries that we use <em>a lot</em> were poorly documented, hard to use, missing features, and there was little motivation in making it better (or, this was relatively low on the <em>“developer experience”</em> priority list).</p>
<p>Specifically, we use Kafka <em>a lot</em>, but the choices were <code>kafkaex</code> (not super actively developed/maintained, and some known broken functionality) and <code>brod</code> (written in Erlang, poorly documented and cryptic error messages). Given how much we depend on Kafka and with the size and reputation of the company, I would say that it’s a huge disappointment to not see investment in making our own Kafka-Elixir integration.</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>Although I ended on a particularly negative point, I really did enjoy coding in Elixir. I will miss the elegance in some of the language constructs but overall, I think I’ll be happier to work in a better supported language. I would definitely consider another job in Elixir as I had enjoyed working in it more than other languages I’ve used in the past. If I were to go back to <code>$COMPANY_THAT_USES_ELIXIR</code>, I might even suggest taking ownership of (or forking) <code>kafkaex</code> or create our own open-sourced Kafka library in Elixir. It’s just a shame that I only thought about this after I left the company.</p>
]]></summary>
</entry>

</feed>
