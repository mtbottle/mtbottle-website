<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Michelle's [uncreative adjective] Blog</title>
    <link href="http://michtran.ca/blog//atom.xml" rel="self" />
    <link href="http://michtran.ca/blog/" />
    <id>http://michtran.ca/blog//atom.xml</id>
    <author>
        <name>Michelle Tran</name>
        <email>email@michtran.ca</email>
    </author>
    <updated>2022-10-29T00:00:00Z</updated>
    <entry>
    <title>Elixir: An Exit Review</title>
    <link href="http://michtran.ca/blog//blog/posts/2022-10-29-Elixir-Exit-Review.html" />
    <id>http://michtran.ca/blog//blog/posts/2022-10-29-Elixir-Exit-Review.html</id>
    <published>2022-10-29T00:00:00Z</published>
    <updated>2022-10-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
<em>Posted on October 29, 2022</em>
    
</div>

<p>I’ve resigned from my job at <code>$COMPANY_THAT_USES_ELIXIR</code> recently. And in my next role, Elixir will not be my primary programming language. Here are some of my thoughts after working with it for 3 years.</p>
<h2 id="introduction">Introduction</h2>
<p>Elixir is a language that is based off of Erlang. This means that it uses the BEAM, which is the Erlang’s virtual machine and also follows Erlang’s OTP design principles.</p>
<p>I went into the job not knowing much about the language, other than the fact that it was 1. functional and 2. saw that it was hyped on places like <code>lobste.rs</code> and our favourite orange tech news aggregation website.</p>
<h2 id="what-i-liked">What I liked</h2>
<h3 id="pattern-matching-and-guards">Pattern Matching and Guards</h3>
<p>This simple feature makes programming so much more fun. I’ve mainly used this to substitute for conditionals. For example, handling different response statuses can look like this:</p>
<pre><code>def handle_resp(%HTTPoison.Response{status_code: 200} = resp), do: ok(resp)

def handle_resp(%HTTPoison.Response{status_code: 403} = resp), do: forbidden(resp)

def handle_resp(%HTTPoison.Response{status_code: 400} = resp), do: not_found(resp)

def handle_resp(%HTTPoison.Response{status_code: status} = resp) when status &gt;= 400 and status &lt; 500 do
  user_error(resp)
end

# handles all other responses, including 3xx, 5xx
def handle_resp(%HTTPoison.Response{} = resp), do: retry()</code></pre>
<p>I’ve found this to be a super elegant way of differentiating the code paths without creating too many levels of indentation. Pattern matching is also super useful to get specific items from maps and more complex data structures too.</p>
<h3 id="pipes">Pipes!</h3>
<p>In particular, the structure of pipes naturally follows the order they’re executed. This makes it <em>so</em> much easier to read the code.</p>
<p>For example, in a standard declarative language, you might write something like this:</p>
<pre><code>last_func(
    third_func(
        second_func(
            first_func(
                param
            )
        )
    )
)</code></pre>
<p>But with Elixir, this can be written much more elegantly:</p>
<pre><code>param
|&gt; first_func()
|&gt; second_func()
|&gt; third_func()
|&gt; last_func()</code></pre>
<p>More languages should adopt this.</p>
<h2 id="what-im-not-sure-about">What I’m not sure about</h2>
<h3 id="genservers-and-otp-design-generally">GenServers (and OTP design generally)</h3>
<p>I was super excited to learn <a href="https://www.erlang.org/doc/design_principles/des_princ.html">about OTP</a> and building applications based on multiple processes. It’s a unique concept with interesting design implications. Thinking in terms of processes, their lifecycles and designing your data around immutability was a fascinating adventure into something completely unique from the standard object-oriented or even functional world.</p>
<p>Although this was intellectually interesting, I don’t think I’ve actually seen it used to its full potential as we seldom needed to code our own GenServers in practice. So admittedly, although this was an interesting excursion into a new idea, I’m not sure I have seen a particularly notable usage of OTP.</p>
<h3 id="interns-struggle">Interns Struggle</h3>
<p>Throughout my 3 years at <code>$COMPANY_THAT_USES_ELIXIR</code>, I’ve found that interns, especially those that are on their first 4 month term with us, really struggle to grasp the language as quickly as other more common languages like Javascript or Python. I’m not entirely sure if my anecdotal evidence is indicative of anything, but it does suggest that there might be something different with Elixir that makes it harder for new coders to get started with. Some of my theories for why it’s harder:</p>
<ol style="list-style-type: decimal">
<li>Students are more likely to learn OOP at school</li>
<li>OTP architectural design doesn’t translate well to more mainstream languages/patterns</li>
<li>Elixir pattern matching, control flows and error handling also doesn’t translate well to more mainstream languages/patterns, which means that prior programming experience doesn’t map as well to patterns used in Elixir</li>
<li>Four months is not long enough to get a good handle on the idiosyncrasies in the language</li>
</ol>
<p>I’ve found that interns on their second or third internship with <code>$COMPANY_THAT_USES_ELIXIR</code> tended to handle the tasks much better.</p>
<h2 id="what-i-didnt-like">What I didn’t like</h2>
<h3 id="with-statements">“with” Statements</h3>
<p>I’ve actually grown a bit more ambivalent with this construct over time. I started to <em>really</em> hate this construct when I ran into some debugging annoyances. For example:</p>
<pre><code>with {:ok, data}      &lt;- function_call(params),
     {:ok, more_data} &lt;- function_call2(),
do
  whatever_here()
else
  {:error, :timeout} -&gt; {:error, :error_in_with_statement}
end</code></pre>
<p>It is impossible to know whether the <code>timeout</code> came from <code>function_call</code> or <code>function_call2</code>. So it’s incredibly hard to trace this call when all you see is <code>{:error, :error_in_with_statement}</code> (not to mention that Elixir’s debugging tools are not great).</p>
<p>One way to get around this is to actually annotate each line like this:</p>
<pre><code>with {:this_line, {:ok, data}}      &lt;- {:this_line, function_call(params)},
     {:that_line, {:ok, more_data}} &lt;- {:that_line, function_call2()},
do
  whatever_here()
else
  {:this_line, {:error, :timeout}} -&gt; 
    add_some_metrics(:this_line)
    {:error, :error_in_with_statement}

  {:that_line, {:error, :timeout}} -&gt; {:error, :error_in_with_statement}
end</code></pre>
<p>This is a reasonable to separate which line caught the error, but makes the code more repetitive (ie. <code>this_line</code> and <code>that_line</code> are repeated 3 times).</p>
<p>I think that <code>with</code> is powerful when you really want to handle a class of errors the same way. Arguably, <code>timeouts</code> <em>should</em> probably be handled the same, but we still need to differentiate where they’re coming from for observability. We can probably use the clunky appended signifier to handle the error in the same way, but differentiated for observability purposes:</p>
<pre><code>with {:this_line, {:ok, data}}      &lt;- {:this_line, function_call(params)},
     {:that_line, {:ok, more_data}} &lt;- {:that_line, function_call2()},
do
  whatever_here()
else
  {line_signifier, {:error, :timeout}} -&gt;
    add_some_metrics(line_signifier)
    {:error, :error_in_with_statement}
end</code></pre>
<p>It’s still a bit repetitive, but gives us the observability for debugging. Anyways, I’ve come to terms that this isn’t <em>that</em> terrible. I’m not sure I <em>like</em> it that much, but I guess I no longer hate it.</p>
<h3 id="lacking-good-third-party-support">Lacking good third party support</h3>
<p>My criticism here is probably more on my ex-company rather than something inherent to Elixir itself.</p>
<p>Elixir is still very immature, and hence, there is a clear lack of support for things that we take for granted in other more mature languages.</p>
<p>This was admittedly, one of the final contributing factors to making me leave <code>$COMPANY_THAT_USES_ELIXIR</code> (there were several others reasons unrelated to Elixir). I was no longer excited with working in Elixir because third party libraries that we use <em>a lot</em> were poorly documented, hard to use, missing features, and there was little motivation in making it better (or, this was relatively low on the <em>“developer experience”</em> priority list).</p>
<p>Specifically, we use Kafka <em>a lot</em>, but the choices were <code>kafkaex</code> (not super actively developed/maintained, and some known broken functionality) and <code>brod</code> (written in Erlang, poorly documented and cryptic error messages). Given how much we depend on Kafka and with the size and reputation of the company, I would say that it’s a huge disappointment to not see investment in making our own Kafka-Elixir integration.</p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>Although I ended on a particularly negative point, I really did enjoy coding in Elixir. I will miss the elegance in some of the language constructs but overall, I think I’ll be happier to work in a better supported language. I would definitely consider another job in Elixir as I enjoyed working in it more than other languages I’ve used in the past. If I were to go back to <code>$COMPANY_THAT_USES_ELIXIR</code>, I might even suggest taking ownership of (or forking) <code>kafkaex</code> or create our own open-sourced Kafka library in Elixir. It’s just a shame that I only thought about this after I left the company.</p>
]]></summary>
</entry>
<entry>
    <title>Project Risk and Time Estimation</title>
    <link href="http://michtran.ca/blog//blog/posts/2022-03-20-project_risk.html" />
    <id>http://michtran.ca/blog//blog/posts/2022-03-20-project_risk.html</id>
    <published>2022-03-20T00:00:00Z</published>
    <updated>2022-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
<em>Posted on March 20, 2022</em>
    
</div>

<p>After years of leading projects, I feel like I’ve finally stopped having an aversion to setting time estimates, and have accepted that they’re a necessary part of project management. Giving these values always feel like I’m just making up a number for the sake of putting in a deadline (ie. <em>bullshitting</em> my way through to project completion). However a shift of mindset from being <em>accurate</em> to doing better <em>expectation management</em> made it easier to accept that putting in a projected deadline is not really that bad.</p>
<p>So this is an article about how I’ve come to not be scared off by work estimation.</p>
<h2 id="why-it-is-important-to-give-a-target-completion">Why it is important to give a target completion</h2>
<p>I will admit that giving a completion estimation is in many ways, <em>actually</em> quite arbitrary. There will be many factors that you will not be able to control, like one of your team member’s employment status or unpredictable increase in oncall reactive maintenance. So, deadlines can shift based on these factors.</p>
<p>However, the importance of giving a target completion, (even when we all know that they tend to slip), is that you can set some expectations to other people in the organization about when they might expect a particular feature. For instance, the sales department will need to know when a feature is going to launch so that they know when they can start “selling” the feature. Customer support will need to know when the feature launch so that they can collate the training materials required to train up customer support agents before the feature is actually launched. We don’t launch in a vacuum. We have other groups relying on what’s coming. If we miss our target, it will affect the delivery of these other dependencies.</p>
<h2 id="is-there-value-in-work-estimation">Is there value in work estimation?</h2>
<p>I have yet to find a good technique to do work estimation in a project well. Generally I found that the better you understand the problem/technology/code/team members, the better your technical breakdown, which means the better your estimate. The more details you can get in your plan, the better the estimate.</p>
<p>The work breakdown and estimation is generally a good start as the initial estimate. This is usually the number I’m most iffy about because there are lots of caveats about the estimation. For instance, if you need to collaborate with another team then the assumption is that there will be <em>no friction</em> between how the developers in each team work together. Or there might be something that we thought was easy, but has turned out more complex than initially planned.</p>
<p>So when I do time or work estimation now, I usually give the work estimation <em>with</em> some sort of risk assessment.</p>
<h2 id="time-estimation-is-about-risk-management">Time Estimation is about Risk Management</h2>
<p>So this leads me to my central thesis: time estimation is about expectation management is about risk management. Using the transitive property on the previous statement, <em>time estimation is about risk management</em>.</p>
<p>Project risk usually occurs in 2 forms:</p>
<ul>
<li>Planning risk</li>
<li>Execution risk</li>
</ul>
<h2 id="what-is-planning-risk">What is planning risk?</h2>
<p>Planning risk usually involves informational uncertainty that has the potential to affect the project deadline.</p>
<p>These risks may look like:</p>
<ul>
<li>unclear requirements (do I have everything I need to work on the project?)</li>
<li>inherent complexity, or “the known landmines”; some projects have a piece that resists decomposition and/or is logically complex.<br />
</li>
<li>overly long or complex critical paths</li>
<li>technology or tools that the team isn’t familiar with</li>
<li>scaling issues</li>
<li>not enough people to work on the project (team too small for the project ambition)</li>
</ul>
<h2 id="what-is-execution-risk">What is execution risk?</h2>
<p>Execution risks usually involve emergent issues that come up as the project progresses.</p>
<p>These risks may look like:</p>
<ul>
<li>dependency on external team</li>
<li>not enough people to work on the project (assigned people pulled into other company priorities)</li>
<li>new unforseen requirements</li>
<li>requirements being more complex than initially planned</li>
<li>operational load or other non-project priorities</li>
</ul>
<h2 id="how-to-use-these-risks-with-time-estimates">How to use these risks with time estimates?</h2>
<p>I no longer provide time estimates without their context anymore. The initial estimate will include the work breakdown. Then status updates (usually on weekly basis) will include:</p>
<ul>
<li>known risks, their probability and impact (can we eat this risk?)</li>
<li>any major decisions made in project and/or a specify risk item</li>
<li>forecasted completion date (can be adjusted based on new risks)</li>
</ul>
<p>Risk tends to change as the project progresses, so risks early in the project (like those risks that usually occur in the planning phase) will get less risky as we get more clarity on their impact and resolution. Execution risks may crop up unexpectedly, so we need to highlight them and adjust timelines as they emerge.</p>
<p>When highlighting the probability and impact of risk, it’s worth thinking about the idea of materialized vs. unmaterialized risk. For example, integrating with a new vendor starts as an unmaterialized risk - we aren’t familiar with the accuracy of their documentation and the reliability of their APIs, but as long as we’ve done what we can with reading their documentation, there’s not much else that can be done until we actually start integrating. If, once we start tackling this integration, we’re running into all sorts of problems, that’s a materialized risk, and requires more direct action/potential deadline adjustment.</p>
<p>This approach is more about <em>communication of expectations</em>, and less about <em>accurate forecasting</em>.</p>
<h2 id="ive-identified-risks-how-do-i-deal-with-them">I’ve identified risks, how do I deal with them?</h2>
<p>This is not an exhaustive list of things that I’ve done with risk that I’ve identified in projects:</p>
<ul>
<li>being explicit about the risk and the potential effects of risk is the first step! unknown or untracked risks are the riskiest!</li>
<li>getting more clarity on the risk will help derisk it (ie. scaling issues, if we can find some numbers to project the expected load, then we’re derisking it)</li>
<li>new process can also help derisk (ie. define cross team syncs to more frequently address cross team collaboration)</li>
<li>recalibrate the projection, taking into account the risk (ie. given that we’re not sure about the load requirements and the potential necessary steps to fix it, are we still confident about the project projection?)</li>
<li>rescope some features (ie. we might be able to hit our target date if we don’t add a cache layer)</li>
<li>for risks associated with landmines/critical paths, we can timebox, swarm or seek additional feedback</li>
<li>wait and see. Sometimes we might want to wait a bit more to see how we progress (e.g. in the case where it seems like we’re slowly veering off forecast, we might call it out and give it a bit more time. While “do nothing” shouldn’t always be the default, it can be a legitimate choice when there isn’t enough of an impetus for concrete action yet.</li>
<li>eat the risk and deal with it after the project. We need to ensure that track this risk and add it to our backlog.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve got a system that currently works for me. Being explicit about risks help set the expectation to stakeholders, and the regular communication builds trust with management. Ultimately, I think this is what matters most in managing projects in a corporate environment. It’s kind of a change from start-up life, where you just hack your way to a product. But when you’ve got more moving pieces to juggle, risk management is the key to giving better time estimates for project completion.</p>
<hr />
<p><em>Acknowledgement:</em> Thanks to Dennis Poon for helping me refine the ideas and thinking through planning vs execution risks.</p>
]]></summary>
</entry>
<entry>
    <title>Why I Read a lot of Books</title>
    <link href="http://michtran.ca/blog//blog/posts/2022-02-23-why_i_read.html" />
    <id>http://michtran.ca/blog//blog/posts/2022-02-23-why_i_read.html</id>
    <published>2022-02-23T00:00:00Z</published>
    <updated>2022-02-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
<em>Posted on February 23, 2022</em>
    
</div>

<p>I try to read 52 books a year. There are people who read more, but many more who read less. A lot of it is fiction, but I also read a lot of non-fiction books too. People who are impressed by how much I read usually ask, <em>“How do you remember everything that you read?”</em>. My answer to that is usually: <em>I don’t</em>.</p>
<p>If I don’t retain everything that I read, then why do I still try to read so many books? Wouldn’t it be better if I read less, but retained more?</p>
<p>I think that reading a lot of books helps me build <em>intuition</em>. I may not remember exactly what lead me to think a certain way, but the accumulated knowledge of the thoroughly edited books that I’ve read leads me to having a better judgement on things.</p>
<p>The classic example is fiction. There are studies that show that people who read a lot of fiction tends to be <a href="https://www.discovermagazine.com/mind/how-reading-fiction-increases-empathy-and-encourages-understanding">more empathetic</a>. Do we remember necessarily which character fits which real life person/situation? Probably not. But the accumulation of the experiences of characters that you read will give you a better understanding of the vast range of human thought.</p>
<p>So, although I don’t retain most of what I read (and I’m also terrible with quoting books), I read because I enjoy reading and also because I’m building my intuition on whatever topic interests me.</p>
]]></summary>
</entry>

</feed>
